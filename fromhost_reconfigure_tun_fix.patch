diff --git a/elements/userlevel/fromhost.cc b/elements/userlevel/fromhost.cc
index 50e5531..6ad4fc6 100644
--- a/elements/userlevel/fromhost.cc
+++ b/elements/userlevel/fromhost.cc
@@ -45,6 +45,9 @@ FromHost::FromHost()
 #if HAVE_IP6
     _prefix6 = 0;
 #endif
+#if HAVE_BATCH
+    in_batch_mode = BATCH_MODE_YES;
+#endif
 }
 
 FromHost::~FromHost()
@@ -86,10 +89,11 @@ FromHost::try_linux_universal(ErrorHandler *errh)
 {
     int fd;
 #ifdef HAVE_PROPER
+    int e;
     fd = prop_open("/dev/net/tun", O_RDWR);
     if (fd >= 0) {
 	if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0) {
-	    int e = errno;
+            e = errno;
 	    errh->error("fcntl /dev/net/tun: %s", strerror(e));
 	    close(fd);
 	    return -e;
@@ -141,7 +145,6 @@ FromHost::setup_tun(ErrorHandler *errh)
 	sa << "/sbin/ifconfig " << _dev_name << " hw ether " << _macaddr.unparse_colon();
 	if (system(sa.c_str()) != 0)
 	    errh->error("%s: %s", sa.c_str(), strerror(errno));
-
 	sa.clear();
 	sa << "/sbin/ifconfig " << _dev_name << " arp";
 	if (system(sa.c_str()) != 0)
@@ -193,19 +196,68 @@ FromHost::dealloc_tun()
   }
 }
 
+FromHost *
+FromHost::hotswap_element() const
+{
+    if (Element *e = Element::hotswap_element())
+        if (FromHost *fh = static_cast<FromHost *>(e->cast("FromHost")))
+            if (fh->_dev_name == _dev_name)
+                return fh;
+    return 0;
+}
+
+void
+FromHost::take_state(Element *e, ErrorHandler *errh)
+{
+    (void)errh;
+    FromHost *o = static_cast<FromHost *>(e); // checked by hotswap_element()
+
+    _fd = o->fd();
+    _dev_name = o->dev_name();
+
+    _mtu_in = o->_mtu_in;
+    _mtu_out = o->_mtu_out;
+
+    _macaddr = o->_macaddr;
+
+    _near = o->_near;
+    _mask = o->_mask;
+    _gw = o->_gw;
+
+#if HAVE_IP6
+    _near6 = o->_near6;
+    _prefix6 = o->_prefix6;
+#endif
+
+    _headroom = o->_headroom;
+
+    o->remove_select(_fd, SELECT_READ);
+    o->_fd = -1;
+}
+
 int
 FromHost::initialize(ErrorHandler *errh)
 {
-    if (try_linux_universal(errh) < 0)
-	return -1;
-    if (setup_tun(errh) < 0)
-	return -1;
+    int ret = -1;
 
     ScheduleInfo::join_scheduler(this, &_task, errh);
     _nonfull_signal = Notifier::downstream_full_signal(this, 0, &_task);
 
+    if (hotswap_element()) {
+        goto out;
+    }
+
+    if (try_linux_universal(errh) < 0)
+        goto err;
+    if (setup_tun(errh) < 0)
+        goto err;
+
     add_select(_fd, SELECT_READ);
-    return 0;
+
+out:
+    ret = 0;
+err:
+    return ret;
 }
 
 void
@@ -223,6 +275,10 @@ FromHost::selected(int fd, int)
     if (fd != _fd)
 	return;
 
+#if HAVE_BATCH
+    BATCH_CREATE_INIT(batch);
+#endif
+
     WritablePacket *p = Packet::make(_headroom, 0, _mtu_in, 0);
     if (!p) {
 	click_chatter("out of memory!");
@@ -239,9 +295,14 @@ FromHost::selected(int fd, int)
 	p->set_dst_ip_anno(IPAddress(ip->ip_dst));
 	p->set_ip_header(ip, ip->ip_hl << 2);
 	p->timestamp_anno().assign_now();
-	output(0).push(p);
+#if HAVE_BATCH
+            BATCH_CREATE_APPEND(batch,p);
+#else
+            output(0).push(p);
+#endif
     } else {
 	p->kill();
+        printf("FromHost read(print)\n");
 	perror("FromHost read");
     }
 
@@ -249,8 +310,11 @@ FromHost::selected(int fd, int)
 	remove_select(_fd, SELECT_READ);
 	return;
     }
-
-
+#if HAVE_BATCH
+    BATCH_CREATE_FINISH(batch);
+    if (batch)
+        output(0).push_batch(batch);
+#endif
 }
 
 bool
@@ -261,7 +325,6 @@ FromHost::run_task(Task *)
 
     add_select(_fd, SELECT_READ);
     return true;
-
 }
 
 String
diff --git a/elements/userlevel/fromhost.hh b/elements/userlevel/fromhost.hh
index 2427d30..96c3e97 100644
--- a/elements/userlevel/fromhost.hh
+++ b/elements/userlevel/fromhost.hh
@@ -92,9 +92,8 @@ CLICK_DECLS
  *
  */
 
-class FromHost : public Element { public:
-
-
+class FromHost : public BatchElement {
+public:
     enum ConfigurePhase {
 	CONFIGURE_PHASE_FROMHOST = CONFIGURE_PHASE_DEFAULT,
 	CONFIGURE_PHASE_TOHOST =  CONFIGURE_PHASE_FROMHOST + 1
@@ -112,6 +111,8 @@ class FromHost : public Element { public:
     int initialize(ErrorHandler *) CLICK_COLD;
     void cleanup(CleanupStage) CLICK_COLD;
     void add_handlers() CLICK_COLD;
+    FromHost *hotswap_element() const;
+    void take_state(Element *, ErrorHandler *);
 
     int fd() const			{ return _fd; }
     String dev_name() const		{ return _dev_name; }
@@ -149,7 +150,6 @@ class FromHost : public Element { public:
     void dealloc_tun();
 
     static String read_param(Element *, void *) CLICK_COLD;
-
 };
 
 CLICK_ENDDECLS
diff --git a/elements/userlevel/tohost.cc b/elements/userlevel/tohost.cc
index c4686c7..20a95c9 100644
--- a/elements/userlevel/tohost.cc
+++ b/elements/userlevel/tohost.cc
@@ -38,8 +38,7 @@
 
 CLICK_DECLS
 
-ToHost::ToHost()
-    : _fd(-1), _drops(0)
+ToHost::ToHost(): _fd(-1), _drops(0)
 {
 }
 
@@ -55,16 +54,17 @@ ToHost::configure(Vector<String> &conf, ErrorHandler *errh)
 	.complete();
 }
 
-int
-ToHost::initialize(ErrorHandler *errh)
+int ToHost::find_fromhost(ErrorHandler *errh)
 {
+    int ei;
+    FromHost *s;
+    Element *e;
+
   //find a FromHost and reuse its socket
-    for (int ei = 0; ei < router()->nelements() && _fd < 0; ei++) {
-	Element *e = router()->element(ei);
-	FromHost *s = (FromHost *)e->cast("FromHost");
-	if (s &&
-	    s->dev_name() == _dev_name &&
-	    s->fd() > 0) {
+    for (ei = 0; ei < router()->nelements() && _fd < 0; ei++) {
+        e = router()->element(ei);
+        s = (FromHost *)e->cast("FromHost");
+        if (s && s->dev_name() == _dev_name && s->fd() > 0) {
 	    _fd = s->fd();
 	    return 0;
 	}
@@ -74,6 +74,70 @@ ToHost::initialize(ErrorHandler *errh)
 		       _dev_name.c_str());
 }
 
+int
+ToHost::initialize(ErrorHandler *errh)
+{
+    if (hotswap_element()) {
+        return 0;
+    }
+
+    return find_fromhost(errh);
+}
+
+ToHost *
+ToHost::hotswap_element() const
+{
+    if (Element *e = Element::hotswap_element())
+        if (ToHost *th = static_cast<ToHost *>(e->cast("ToHost")))
+            if (th->_dev_name == _dev_name)
+                return th;
+    return 0;
+}
+
+void
+ToHost::take_state(Element *e, ErrorHandler *errh)
+{
+    (void)e;
+    find_fromhost(errh);
+}
+
+#if HAVE_BATCH
+void
+ToHost::push_batch(int, PacketBatch *b)
+{
+    int w;
+    click_ether *e = NULL;
+    static bool _printed_write_err = false;
+    WritablePacket *q = NULL;
+
+    FOR_EACH_PACKET_SAFE(b,p) {
+        if (p->length() < sizeof(click_ether)) {
+            click_chatter("ToHost: packet too small");
+            p->kill();
+            continue;
+        }
+
+        /* 2-byte padding followed by an Ethernet type */
+        q = p->push(4);
+        if (q) {
+            e = (click_ether *) (p->data() + 4);
+            *(uint32_t *)(q->data()) = e->ether_type;
+
+            w = write(_fd, q->data(), q->length());
+            _printed_write_err = false;
+            if (w != (int) q->length() && (errno != ENOBUFS || !_printed_write_err)) {
+                _printed_write_err = true;
+                ++_drops;
+                click_chatter("ToHost(%s): write failed: %s", _dev_name.c_str(), strerror(errno));
+            }
+            q->kill();
+        } else {
+            click_chatter("%p{element}: out of memory", this);
+        }
+    }
+}
+#endif
+
 void
 ToHost::push(int, Packet *p)
 {
@@ -97,9 +161,10 @@ ToHost::push(int, Packet *p)
 	    click_chatter("ToHost(%s): write failed: %s", _dev_name.c_str(), strerror(errno));
 	}
 	q->kill();
-    } else
+    } else {
 	click_chatter("%p{element}: out of memory", this);
 }
+}
 
 void
 ToHost::add_handlers()
diff --git a/elements/userlevel/tohost.hh b/elements/userlevel/tohost.hh
index a3abf1a..b6bcdb0 100644
--- a/elements/userlevel/tohost.hh
+++ b/elements/userlevel/tohost.hh
@@ -44,8 +44,8 @@ CLICK_DECLS
  *
  */
 
-class ToHost : public Element { public:
-
+class ToHost : public BatchElement {
+public:
     ToHost() CLICK_COLD;
     ~ToHost() CLICK_COLD;
 
@@ -57,15 +57,20 @@ class ToHost : public Element { public:
     int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
     int initialize(ErrorHandler *) CLICK_COLD;
     void add_handlers() CLICK_COLD;
-
+    ToHost *hotswap_element() const;
+    void take_state(Element *, ErrorHandler *);
+#if HAVE_BATCH
+    void push_batch(int, PacketBatch *);
+#endif
     void push(int port, Packet *);
 
   private:
-
     int _fd;
     int _drops;
     String _dev_name;
 
+    int find_fromhost(ErrorHandler *);
+
 };
 
 CLICK_ENDDECLS
