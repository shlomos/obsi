diff --git a/elements/userlevel/fromhost.cc b/elements/userlevel/fromhost.cc
index 50e5531..4cc3cca 100644
--- a/elements/userlevel/fromhost.cc
+++ b/elements/userlevel/fromhost.cc
@@ -40,10 +40,10 @@
 CLICK_DECLS
 
 FromHost::FromHost()
-    : _fd(-1), _task(this)
+	: _fd(-1), _task(this)
 {
 #if HAVE_IP6
-    _prefix6 = 0;
+	_prefix6 = 0;
 #endif
 }
 
@@ -54,228 +54,275 @@ FromHost::~FromHost()
 int
 FromHost::configure(Vector<String> &conf, ErrorHandler *errh)
 {
-    _headroom = Packet::default_headroom;
-    _headroom += (4 - (_headroom + 2) % 4) % 4; // default 4/2 alignment
-    _mtu_out = DEFAULT_MTU;
-
-    if (Args(conf, this, errh)
-	.read_mp("DEVNAME", _dev_name)
-	.read_p("DST", IPPrefixArg(), _near, _mask)
-	.read("GATEWAY", _gw)
+	_headroom = Packet::default_headroom;
+	_headroom += (4 - (_headroom + 2) % 4) % 4; // default 4/2 alignment
+	_mtu_out = DEFAULT_MTU;
+
+	if (Args(conf, this, errh)
+			.read_mp("DEVNAME", _dev_name)
+			.read_p("DST", IPPrefixArg(), _near, _mask)
+			.read("GATEWAY", _gw)
 #if HAVE_IP6 && 0
-	// XXX
-	"DST6", 0, cpIP6PrefixLen, &_near6, &_prefix6,
+			// XXX
+			"DST6", 0, cpIP6PrefixLen, &_near6, &_prefix6,
 #endif
-	.read("ETHER", _macaddr)
-	.read("HEADROOM", _headroom)
-	.read("MTU", _mtu_out)
-	.complete() < 0)
-	return -1;
-
-    if (_near && _gw && !_gw.matches_prefix(_near, _mask))
-	return errh->error("bad GATEWAY");
-    if (!_dev_name)
-	return errh->error("must specify device name");
-    if (_headroom > 8192)
-	return errh->error("HEADROOM too large");
-    return 0;
+			.read("ETHER", _macaddr)
+			.read("HEADROOM", _headroom)
+			.read("MTU", _mtu_out)
+			.complete() < 0)
+		return -1;
+
+	if (_near && _gw && !_gw.matches_prefix(_near, _mask))
+		return errh->error("bad GATEWAY");
+	if (!_dev_name)
+		return errh->error("must specify device name");
+	if (_headroom > 8192)
+		return errh->error("HEADROOM too large");
+	return 0;
 }
 
 int
 FromHost::try_linux_universal(ErrorHandler *errh)
 {
-    int fd;
+	int fd;
 #ifdef HAVE_PROPER
-    fd = prop_open("/dev/net/tun", O_RDWR);
-    if (fd >= 0) {
-	if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0) {
-	    int e = errno;
-	    errh->error("fcntl /dev/net/tun: %s", strerror(e));
-	    close(fd);
-	    return -e;
-	}
-    } else
-	errh->warning("prop_open /dev/net/tun: %s", strerror(errno));
-    if (fd < 0)
+	int e;
+	fd = prop_open("/dev/net/tun", O_RDWR);
+	if (fd >= 0) {
+		if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0) {
+			e = errno;
+			errh->error("fcntl /dev/net/tun: %s", strerror(e));
+			close(fd);
+			return -e;
+		}
+	} else
+		errh->warning("prop_open /dev/net/tun: %s", strerror(errno));
+		if (fd < 0)
 #endif
-    fd = open("/dev/net/tun", O_RDWR | O_NONBLOCK);
-    if (fd < 0) {
-	int e = errno;
-	errh->error("open /dev/net/tun: %s", strerror(e));
-	return -e;
-    }
-
-    struct ifreq ifr;
-    memset(&ifr, 0, sizeof(ifr));
-    /* we want an ethertap-like interface */
-    ifr.ifr_flags = IFF_TAP;
-
-    /*
-     * setting ifr_name this allows us to select an aribitrary
-     * interface name.
-     */
-    strcpy(ifr.ifr_name, _dev_name.c_str());
-
-    int err = ioctl(fd, TUNSETIFF, (void *)&ifr);
-    if (err < 0) {
-	errh->warning("Linux universal tun failed for %s: %s",
-		      _dev_name.c_str(),
-		      strerror(errno));
-	close(fd);
-	return -errno;
-    }
-
-    _dev_name = ifr.ifr_name;
-    _fd = fd;
-    return 0;
+	fd = open("/dev/net/tun", O_RDWR | O_NONBLOCK);
+	if (fd < 0) {
+		int e = errno;
+		errh->error("open /dev/net/tun: %s", strerror(e));
+		return -e;
+	}
+
+	struct ifreq ifr;
+	memset(&ifr, 0, sizeof(ifr));
+	/* we want an ethertap-like interface */
+	ifr.ifr_flags = IFF_TAP;
+
+	/*
+	 * setting ifr_name this allows us to select an aribitrary
+	 * interface name.
+	 */
+	strcpy(ifr.ifr_name, _dev_name.c_str());
+
+	int err = ioctl(fd, TUNSETIFF, (void *)&ifr);
+	if (err < 0) {
+		errh->warning("Linux universal tun failed for %s: %s",
+				  _dev_name.c_str(),
+				  strerror(errno));
+		close(fd);
+		return -errno;
+	}
+
+	_dev_name = ifr.ifr_name;
+	_fd = fd;
+	return 0;
 }
 
 int
 FromHost::setup_tun(ErrorHandler *errh)
 {
-    StringAccum sa;
-    const char *up = " up";
-
-    if (_macaddr) {
-	sa.clear();
-	sa << "/sbin/ifconfig " << _dev_name << " hw ether " << _macaddr.unparse_colon();
-	if (system(sa.c_str()) != 0)
-	    errh->error("%s: %s", sa.c_str(), strerror(errno));
-
-	sa.clear();
-	sa << "/sbin/ifconfig " << _dev_name << " arp";
-	if (system(sa.c_str()) != 0)
-	    return errh->error("%s: couldn't set arp flags: %s", sa.c_str(), strerror(errno));
-    }
-
-    if (_near) {
-	sa.clear();
-	sa << "/sbin/ifconfig " << _dev_name << " " << _near << " netmask " << _mask << up << " 2>/dev/null";
-	if (system(sa.c_str()) != 0)
-	    return errh->error("%s: %<%s%> failed\n(Perhaps Ethertap is in a kernel module that you haven't loaded yet?)", _dev_name.c_str(), sa.c_str());
-	up = "";
-    }
-
-    if (_gw) {
-	sa.clear();
-	sa << "/sbin/route -n add default ";
+	StringAccum sa;
+	const char *up = " up";
+
+	if (_macaddr) {
+		sa.clear();
+		sa << "/sbin/ifconfig " << _dev_name << " hw ether " << _macaddr.unparse_colon();
+		if (system(sa.c_str()) != 0)
+			errh->error("%s: %s", sa.c_str(), strerror(errno));
+		sa.clear();
+		sa << "/sbin/ifconfig " << _dev_name << " arp";
+		if (system(sa.c_str()) != 0)
+			return errh->error("%s: couldn't set arp flags: %s", sa.c_str(), strerror(errno));
+	}
+
+	if (_near) {
+		sa.clear();
+		sa << "/sbin/ifconfig " << _dev_name << " " << _near << " netmask " << _mask << up << " 2>/dev/null";
+		if (system(sa.c_str()) != 0)
+			return errh->error("%s: %<%s%> failed\n(Perhaps Ethertap is in a kernel module that you haven't loaded yet?)", _dev_name.c_str(), sa.c_str());
+		up = "";
+	}
+
+	if (_gw) {
+		sa.clear();
+		sa << "/sbin/route -n add default ";
 #if defined(__linux__)
-	sa << "gw ";
+		sa << "gw ";
 #endif
-	sa << _gw;
-	if (system(sa.c_str()) != 0)
-	    return errh->error("%s: %<%s%> failed", _dev_name.c_str(), sa.c_str());
-    }
+		sa << _gw;
+		if (system(sa.c_str()) != 0)
+			return errh->error("%s: %<%s%> failed", _dev_name.c_str(), sa.c_str());
+	}
 
 #if HAVE_IP6
     if (_near6) {
-	sa.clear();
-	sa << "/sbin/ifconfig " << _dev_name << " inet6 add " << _near6 << "/" << _prefix6 << up << " 2>/dev/null";
-	if (system(sa.c_str()) != 0)
-	    return errh->error("%s: %<%s%> failed", _dev_name.c_str(), sa.c_str());
-	up = "";
-    }
+		sa.clear();
+		sa << "/sbin/ifconfig " << _dev_name << " inet6 add " << _near6 << "/" << _prefix6 << up << " 2>/dev/null";
+		if (system(sa.c_str()) != 0)
+			return errh->error("%s: %<%s%> failed", _dev_name.c_str(), sa.c_str());
+		up = "";
+	}
 #endif
 
-    // calculate maximum packet size needed to receive data from
-    // tun/tap.
-    _mtu_in = _mtu_out + 4;
-    return 0;
+	// calculate maximum packet size needed to receive data from
+	// tun/tap.
+	_mtu_in = _mtu_out + 4;
+	return 0;
 }
 
 void
 FromHost::dealloc_tun()
 {
-  if (_near) {
-      String cmd = "/sbin/ifconfig " + _dev_name + " down";
-      if (system(cmd.c_str()) != 0)
-	  click_chatter("%s: failed: %s", name().c_str(), cmd.c_str());
-  }
+	if (_near) {
+		String cmd = "/sbin/ifconfig " + _dev_name + " down";
+		if (system(cmd.c_str()) != 0)
+			click_chatter("%s: failed: %s", name().c_str(), cmd.c_str());
+	}
+}
+
+FromHost *
+FromHost::hotswap_element() const
+{
+	if (Element *e = Element::hotswap_element())
+		if (FromHost *fh = static_cast<FromHost *>(e->cast("FromHost")))
+			if (fh->_dev_name == _dev_name)
+				return fh;
+	return 0;
+}
+
+void
+FromHost::take_state(Element *e, ErrorHandler *errh)
+{
+	(void)errh;
+	FromHost *o = static_cast<FromHost *>(e); // checked by hotswap_element()
+
+	_fd = o->fd();
+	_dev_name = o->dev_name();
+
+	_mtu_in = o->_mtu_in;
+	_mtu_out = o->_mtu_out;
+
+	_macaddr = o->_macaddr;
+
+	_near = o->_near;
+	_mask = o->_mask;
+	_gw = o->_gw;
+
+#if HAVE_IP6
+	_near6 = o->_near6;
+	_prefix6 = o->_prefix6;
+#endif
+
+	_headroom = o->_headroom;
+
+	o->remove_select(_fd, SELECT_READ);
+	o->_fd = -1;
 }
 
 int
 FromHost::initialize(ErrorHandler *errh)
 {
-    if (try_linux_universal(errh) < 0)
-	return -1;
-    if (setup_tun(errh) < 0)
-	return -1;
-
-    ScheduleInfo::join_scheduler(this, &_task, errh);
-    _nonfull_signal = Notifier::downstream_full_signal(this, 0, &_task);
+	int ret = -1;
+	
+	ScheduleInfo::join_scheduler(this, &_task, errh);
+	_nonfull_signal = Notifier::downstream_full_signal(this, 0, &_task);
 
-    add_select(_fd, SELECT_READ);
-    return 0;
+	if (hotswap_element()) {
+		goto out;
+	}
+	
+	if (try_linux_universal(errh) < 0)
+		goto err;
+	if (setup_tun(errh) < 0)
+		goto err;
+
+	add_select(_fd, SELECT_READ);
+
+out:
+	ret = 0;
+err:
+	return ret;
 }
 
 void
 FromHost::cleanup(CleanupStage)
 {
-    if (_fd >= 0) {
-	close(_fd);
-	remove_select(_fd, SELECT_READ);
-    }
+	if (_fd >= 0) {
+		close(_fd);
+		remove_select(_fd, SELECT_READ);
+	}
 }
 
 void
 FromHost::selected(int fd, int)
 {
-    if (fd != _fd)
-	return;
-
-    WritablePacket *p = Packet::make(_headroom, 0, _mtu_in, 0);
-    if (!p) {
-	click_chatter("out of memory!");
-	return;
-    }
-
-    int cc = read(_fd, p->data(), _mtu_in);
-    if (cc > 0) {
-	p->take(_mtu_in - cc);
-	// 2-byte padding followed by an Ethernet type
-	p->pull(4);
-	p->set_mac_header(p->data());
-	const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + sizeof(click_ether));
-	p->set_dst_ip_anno(IPAddress(ip->ip_dst));
-	p->set_ip_header(ip, ip->ip_hl << 2);
-	p->timestamp_anno().assign_now();
-	output(0).push(p);
-    } else {
-	p->kill();
-	perror("FromHost read");
-    }
-
-    if (!_nonfull_signal) {
-	remove_select(_fd, SELECT_READ);
-	return;
-    }
+	if (fd != _fd)
+		return;
 
+	WritablePacket *p = Packet::make(_headroom, 0, _mtu_in, 0);
+	if (!p) {
+		click_chatter("out of memory!");
+		return;
+	}
 
+	int cc = read(_fd, p->data(), _mtu_in);
+	if (cc > 0) {
+		p->take(_mtu_in - cc);
+		// 2-byte padding followed by an Ethernet type
+		p->pull(4);
+		p->set_mac_header(p->data());
+		const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + sizeof(click_ether));
+		p->set_dst_ip_anno(IPAddress(ip->ip_dst));
+		p->set_ip_header(ip, ip->ip_hl << 2);
+		p->timestamp_anno().assign_now();
+		output(0).push(p);
+	} else {
+		p->kill();
+		printf("FromHost read(print)\n");
+		perror("FromHost read");
+	}
+
+	if (!_nonfull_signal) {
+		remove_select(_fd, SELECT_READ);
+		return;
+	}
 }
 
 bool
 FromHost::run_task(Task *)
 {
-    if (!_nonfull_signal)
-	return false;
-
-    add_select(_fd, SELECT_READ);
-    return true;
+	if (!_nonfull_signal)
+		return false;
 
+	add_select(_fd, SELECT_READ);
+	return true;
 }
 
 String
 FromHost::read_param(Element *e, void *)
 {
-    FromHost *fh = static_cast<FromHost *>(e);
-    return String(fh->_nonfull_signal.active());
+	FromHost *fh = static_cast<FromHost *>(e);
+	return String(fh->_nonfull_signal.active());
 }
 
 void
 FromHost::add_handlers()
 {
-    add_data_handlers("dev_name", Handler::OP_READ, &_dev_name);
-    add_read_handler("signal", read_param, 0);
+	add_data_handlers("dev_name", Handler::OP_READ, &_dev_name);
+	add_read_handler("signal", read_param, 0);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/userlevel/fromhost.hh b/elements/userlevel/fromhost.hh
index 2427d30..1309137 100644
--- a/elements/userlevel/fromhost.hh
+++ b/elements/userlevel/fromhost.hh
@@ -92,64 +92,64 @@ CLICK_DECLS
  *
  */
 
-class FromHost : public Element { public:
+class FromHost : public Element {
+public:
+	enum ConfigurePhase {
+		CONFIGURE_PHASE_FROMHOST = CONFIGURE_PHASE_DEFAULT,
+		CONFIGURE_PHASE_TOHOST =  CONFIGURE_PHASE_FROMHOST + 1
+	};
 
+	FromHost() CLICK_COLD;
+	~FromHost() CLICK_COLD;
 
-    enum ConfigurePhase {
-	CONFIGURE_PHASE_FROMHOST = CONFIGURE_PHASE_DEFAULT,
-	CONFIGURE_PHASE_TOHOST =  CONFIGURE_PHASE_FROMHOST + 1
-    };
+	const char *class_name() const	{ return "FromHost"; }
+	const char *port_count() const	{ return PORTS_0_1; }
+	const char *processing() const	{ return PUSH; }
 
-    FromHost() CLICK_COLD;
-    ~FromHost() CLICK_COLD;
+	int configure_phase() const		{ return CONFIGURE_PHASE_FROMHOST; }
+	int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
+	int initialize(ErrorHandler *) CLICK_COLD;
+	void cleanup(CleanupStage) CLICK_COLD;
+	void add_handlers() CLICK_COLD;
+	FromHost *hotswap_element() const;
+	void take_state(Element *, ErrorHandler *);
 
-    const char *class_name() const	{ return "FromHost"; }
-    const char *port_count() const	{ return PORTS_0_1; }
-    const char *processing() const	{ return PUSH; }
+	int fd() const			{ return _fd; }
+	String dev_name() const		{ return _dev_name; }
 
-    int configure_phase() const		{ return CONFIGURE_PHASE_FROMHOST; }
-    int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
-    int initialize(ErrorHandler *) CLICK_COLD;
-    void cleanup(CleanupStage) CLICK_COLD;
-    void add_handlers() CLICK_COLD;
+	void selected(int fd, int mask);
+	bool run_task(Task *);
 
-    int fd() const			{ return _fd; }
-    String dev_name() const		{ return _dev_name; }
+private:
+	enum { DEFAULT_MTU = 2048 };
 
-    void selected(int fd, int mask);
-    bool run_task(Task *);
+	int _fd;
+	int _mtu_in;
+	int _mtu_out;
+	String _dev_name;
 
-  private:
-    enum { DEFAULT_MTU = 2048 };
+	EtherAddress _macaddr;
 
-    int _fd;
-    int _mtu_in;
-    int _mtu_out;
-    String _dev_name;
-
-    EtherAddress _macaddr;
-
-    IPAddress _near;
-    IPAddress _mask;
-    IPAddress _gw;
+	IPAddress _near;
+	IPAddress _mask;
+	IPAddress _gw;
 
 #if HAVE_IP6
-    IP6Address _near6;
-    int _prefix6;
+	IP6Address _near6;
+	int _prefix6;
 #endif
 
-    unsigned _headroom;
-    Task _task;
-    NotifierSignal _nonfull_signal;
-
-    int try_linux_universal(ErrorHandler *);
-    int try_tun(const String &, ErrorHandler *);
-    int alloc_tun(ErrorHandler *);
-    int setup_tun(ErrorHandler *);
-    void dealloc_tun();
+	unsigned _headroom;
+	Task _task;
+	NotifierSignal _nonfull_signal;
 
-    static String read_param(Element *, void *) CLICK_COLD;
+	int try_linux_universal(ErrorHandler *);
+	int try_tun(const String &, ErrorHandler *);
+	int alloc_tun(ErrorHandler *);
+	int setup_tun(ErrorHandler *);
+	void dealloc_tun();
 
+	static String read_param(Element *, void *) CLICK_COLD;
 };
 
 CLICK_ENDDECLS
diff --git a/elements/userlevel/tohost.cc b/elements/userlevel/tohost.cc
index c4686c7..acbe147 100644
--- a/elements/userlevel/tohost.cc
+++ b/elements/userlevel/tohost.cc
@@ -38,8 +38,7 @@
 
 CLICK_DECLS
 
-ToHost::ToHost()
-    : _fd(-1), _drops(0)
+ToHost::ToHost(): _fd(-1), _drops(0)
 {
 }
 
@@ -50,62 +49,91 @@ ToHost::~ToHost()
 int
 ToHost::configure(Vector<String> &conf, ErrorHandler *errh)
 {
-    return Args(conf, this, errh)
-	.read_mp("DEVNAME", _dev_name)
-	.complete();
+	return Args(conf, this, errh)
+			.read_mp("DEVNAME", _dev_name)
+			.complete();
+}
+
+int ToHost::find_fromhost(ErrorHandler *errh)
+{
+	int ei;
+	FromHost *s;
+	Element *e;
+
+	//find a FromHost and reuse its socket
+	for (ei = 0; ei < router()->nelements() && _fd < 0; ei++) {
+		e = router()->element(ei);
+		s = (FromHost *)e->cast("FromHost");
+		if (s && s->dev_name() == _dev_name && s->fd() > 0) {
+			_fd = s->fd();
+			return 0;
+		}
+	}
+
+	return errh->error("ToHost(%s) requires an initialized FromHost with the same dev_name",
+			_dev_name.c_str());
 }
 
 int
 ToHost::initialize(ErrorHandler *errh)
 {
-  //find a FromHost and reuse its socket
-    for (int ei = 0; ei < router()->nelements() && _fd < 0; ei++) {
-	Element *e = router()->element(ei);
-	FromHost *s = (FromHost *)e->cast("FromHost");
-	if (s &&
-	    s->dev_name() == _dev_name &&
-	    s->fd() > 0) {
-	    _fd = s->fd();
-	    return 0;
+	if (hotswap_element()) {
+		return 0;
 	}
-    }
 
-    return errh->error("ToHost(%s) requires an initialized FromHost with the same dev_name",
-		       _dev_name.c_str());
+	return find_fromhost(errh);
+}
+
+ToHost *
+ToHost::hotswap_element() const
+{
+	if (Element *e = Element::hotswap_element())
+		if (ToHost *th = static_cast<ToHost *>(e->cast("ToHost")))
+			if (th->_dev_name == _dev_name)
+				return th;
+	return 0;
+}
+
+void
+ToHost::take_state(Element *e, ErrorHandler *errh)
+{
+	(void)e;
+	find_fromhost(errh);
 }
 
 void
 ToHost::push(int, Packet *p)
 {
-    if (p->length() < sizeof(click_ether)) {
-	click_chatter("ToHost: packet too small");
-	p->kill();
-	return;
-    }
-
-    // 2-byte padding followed by an Ethernet type
-    WritablePacket *q = p->push(4);
-    if (q) {
-	click_ether *e = (click_ether *) (p->data() + 4);
-	*(uint32_t *)(q->data()) = e->ether_type;
-
-	int w = write(_fd, q->data(), q->length());
-	static bool _printed_write_err = false;
-	if (w != (int) q->length() && (errno != ENOBUFS || !_printed_write_err)) {
-	    _printed_write_err = true;
-	    ++_drops;
-	    click_chatter("ToHost(%s): write failed: %s", _dev_name.c_str(), strerror(errno));
+	if (p->length() < sizeof(click_ether)) {
+		click_chatter("ToHost: packet too small");
+		p->kill();
+		return;
+	}
+
+	// 2-byte padding followed by an Ethernet type
+	WritablePacket *q = p->push(4);
+	if (q) {
+		click_ether *e = (click_ether *) (p->data() + 4);
+		*(uint32_t *)(q->data()) = e->ether_type;
+
+		int w = write(_fd, q->data(), q->length());
+		static bool _printed_write_err = false;
+		if (w != (int) q->length() && (errno != ENOBUFS || !_printed_write_err)) {
+			_printed_write_err = true;
+			++_drops;
+			click_chatter("ToHost(%s): write failed: %s", _dev_name.c_str(), strerror(errno));
+		}
+		q->kill();
+	} else {
+		click_chatter("%p{element}: out of memory", this);
 	}
-	q->kill();
-    } else
-	click_chatter("%p{element}: out of memory", this);
 }
 
 void
 ToHost::add_handlers()
 {
-    add_data_handlers("dev_name", Handler::OP_READ, &_dev_name);
-    add_data_handlers("drops", Handler::OP_READ, &_drops);
+	add_data_handlers("dev_name", Handler::OP_READ, &_dev_name);
+	add_data_handlers("drops", Handler::OP_READ, &_drops);
 }
 
 CLICK_ENDDECLS
diff --git a/elements/userlevel/tohost.hh b/elements/userlevel/tohost.hh
index a3abf1a..545f0d8 100644
--- a/elements/userlevel/tohost.hh
+++ b/elements/userlevel/tohost.hh
@@ -44,27 +44,30 @@ CLICK_DECLS
  *
  */
 
-class ToHost : public Element { public:
+class ToHost : public Element {
+public:
+	ToHost() CLICK_COLD;
+	~ToHost() CLICK_COLD;
 
-    ToHost() CLICK_COLD;
-    ~ToHost() CLICK_COLD;
+	const char *class_name() const	{ return "ToHost"; }
+	const char *port_count() const	{ return PORTS_1_0; }
+	const char *processing() const	{ return PUSH; }
 
-    const char *class_name() const	{ return "ToHost"; }
-    const char *port_count() const	{ return PORTS_1_0; }
-    const char *processing() const	{ return PUSH; }
+	int configure_phase() const		{ return FromHost::CONFIGURE_PHASE_TOHOST; }
+	int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
+	int initialize(ErrorHandler *) CLICK_COLD;
+	void add_handlers() CLICK_COLD;
+	ToHost *hotswap_element() const;
+	void take_state(Element *, ErrorHandler *);
 
-    int configure_phase() const		{ return FromHost::CONFIGURE_PHASE_TOHOST; }
-    int configure(Vector<String> &, ErrorHandler *) CLICK_COLD;
-    int initialize(ErrorHandler *) CLICK_COLD;
-    void add_handlers() CLICK_COLD;
+	void push(int port, Packet *);
 
-    void push(int port, Packet *);
+private:
+	int _fd;
+	int _drops;
+	String _dev_name;
 
-  private:
-
-    int _fd;
-    int _drops;
-    String _dev_name;
+	int find_fromhost(ErrorHandler *);
 
 };
 
